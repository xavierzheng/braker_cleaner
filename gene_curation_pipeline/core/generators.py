#!/usr/bin/env python3

"""
Output generation classes for cleaned annotations and sequences.
"""

import logging
from pathlib import Path
from typing import Dict, List, Set
from .data_structures import Gene, Transcript


class OutputGenerator:
    """Generate output files with format preservation."""
    
    def __init__(self, input_format: str, preserve_source_names: bool = True, 
                 include_quality_flags: bool = True):
        self.input_format = input_format
        self.preserve_source_names = preserve_source_names
        self.include_quality_flags = include_quality_flags
    
    def generate_outputs(self, genes: Dict[str, Gene], output_dir: str,
                        cds_sequences: Dict[str, str], aa_sequences: Dict[str, str]) -> List[str]:
        """Generate all output files."""
        output_files = []
        output_path = Path(output_dir)
        
        # Generate cleaned annotations
        annotation_file = self._generate_cleaned_annotations(genes, output_path)
        output_files.append(annotation_file)
        
        # Generate cleaned sequences
        cds_file = self._generate_cleaned_cds(genes, cds_sequences, output_path)
        aa_file = self._generate_cleaned_aa(genes, aa_sequences, output_path)
        output_files.extend([cds_file, aa_file])
        
        # Generate reports
        report_files = self._generate_reports(genes, output_path)
        output_files.extend(report_files)
        
        return output_files
    
    def _generate_cleaned_annotations(self, genes: Dict[str, Gene], output_path: Path) -> str:
        """Generate cleaned annotation file."""
        # Determine output filename based on input format
        if self.input_format == "GTF":
            filename = "cleaned.gtf"
        else:
            filename = "cleaned.gff3"
        
        output_file = output_path / filename
        
        with open(output_file, 'w') as f:
            # Write header
            f.write(f"##gff-version 3\n")
            f.write(f"# Generated by Gene Curation Pipeline\n")
            f.write(f"# Input format: {self.input_format}\n")
            f.write(f"# Representative transcripts only\n\n")
            
            # Process genes with representatives
            for gene in genes.values():
                if not gene.representative_transcript:
                    continue
                
                transcript = gene.representative_transcript
                
                # Update gene boundaries based on transcript
                gene_start = min(transcript.start, min((e.start for e in transcript.exons), default=transcript.start))
                gene_end = max(transcript.end, max((e.end for e in transcript.exons), default=transcript.end))
                
                # Write gene feature
                self._write_gene_feature(f, gene.id, transcript.chrom, transcript.source,
                                       gene_start, gene_end, transcript.strand)
                
                # Write transcript feature
                self._write_transcript_feature(f, transcript)
                
                # Write exons (sorted by coordinate)
                sorted_exons = sorted(transcript.exons, key=lambda x: x.start)
                for i, exon in enumerate(sorted_exons, 1):
                    self._write_exon_feature(f, exon, transcript, i)
                
                # Write CDS regions (sorted by coordinate)
                sorted_cds = sorted(transcript.cds_regions, key=lambda x: x.start)
                for cds in sorted_cds:
                    self._write_cds_feature(f, cds, transcript)
                
                # Note: start_codon and stop_codon features are NOT written
                # as per specification - they should be integrated into exons/CDS
        
        logging.info(f"Generated cleaned annotations: {output_file}")
        return str(output_file)
    
    def _write_gene_feature(self, f, gene_id: str, chrom: str, source: str,
                           start: int, end: int, strand: str) -> None:
        """Write gene feature."""
        if self.input_format == "GTF":
            attributes = f'gene_id "{gene_id}";'
        else:
            attributes = f'ID={gene_id}'
        
        f.write(f"{chrom}\t{source}\tgene\t{start}\t{end}\t.\t{strand}\t.\t{attributes}\n")
    
    def _write_transcript_feature(self, f, transcript: Transcript) -> None:
        """Write transcript feature."""
        feature_type = "transcript" if self.input_format == "GTF" else "mRNA"
        
        if self.input_format == "GTF":
            attributes = f'gene_id "{transcript.gene_id}"; transcript_id "{transcript.id}";'
        else:
            attributes = f'ID={transcript.id}; Parent={transcript.gene_id}'
        
        # Quality flags are not included in GTF/GFF3 output per user request
        
        f.write(f"{transcript.chrom}\t{transcript.source}\t{feature_type}\t"
               f"{transcript.start}\t{transcript.end}\t.\t{transcript.strand}\t.\t{attributes}\n")
    
    def _write_exon_feature(self, f, exon, transcript: Transcript, exon_number: int) -> None:
        """Write exon feature."""
        if self.input_format == "GTF":
            attributes = (f'gene_id "{transcript.gene_id}"; transcript_id "{transcript.id}"; '
                         f'exon_number "{exon_number}";')
        else:
            exon_id = f"{transcript.id}.exon{exon_number}"
            attributes = f'ID={exon_id}; Parent={transcript.id}'
        
        f.write(f"{transcript.chrom}\t{transcript.source}\texon\t"
               f"{exon.start}\t{exon.end}\t.\t{exon.strand}\t.\t{attributes}\n")
    
    def _write_cds_feature(self, f, cds, transcript: Transcript) -> None:
        """Write CDS feature."""
        if self.input_format == "GTF":
            attributes = f'gene_id "{transcript.gene_id}"; transcript_id "{transcript.id}";'
        else:
            cds_id = f"{transcript.id}.cds.{cds.start}"
            attributes = f'ID={cds_id}; Parent={transcript.id}'
        
        f.write(f"{transcript.chrom}\t{transcript.source}\tCDS\t"
               f"{cds.start}\t{cds.end}\t.\t{cds.strand}\t{cds.phase}\t{attributes}\n")
    
    def _generate_cleaned_cds(self, genes: Dict[str, Gene], cds_sequences: Dict[str, str],
                             output_path: Path) -> str:
        """Generate cleaned CDS sequences."""
        output_file = output_path / "cleaned.cds.fa"
        
        with open(output_file, 'w') as f:
            for gene in genes.values():
                if not gene.representative_transcript:
                    continue
                
                transcript = gene.representative_transcript
                sequence = cds_sequences.get(transcript.id, transcript.cds_sequence)
                
                if not sequence:
                    continue
                
                # Create header with quality flags
                header = f">{transcript.id}"
                if self.include_quality_flags and transcript.quality_flags:
                    flags = ",".join(sorted(transcript.quality_flags))
                    header += f" # {flags}"
                
                f.write(header + "\n")
                
                # Write sequence in 80-character lines
                for i in range(0, len(sequence), 80):
                    f.write(sequence[i:i+80] + "\n")
        
        logging.info(f"Generated cleaned CDS sequences: {output_file}")
        return str(output_file)
    
    def _generate_cleaned_aa(self, genes: Dict[str, Gene], aa_sequences: Dict[str, str],
                            output_path: Path) -> str:
        """Generate cleaned amino acid sequences."""
        output_file = output_path / "cleaned.aa"
        
        with open(output_file, 'w') as f:
            for gene in genes.values():
                if not gene.representative_transcript:
                    continue
                
                transcript = gene.representative_transcript
                sequence = aa_sequences.get(transcript.id, transcript.aa_sequence)
                
                if not sequence:
                    continue
                
                # Create header with quality flags
                header = f">{transcript.id}"
                if self.include_quality_flags and transcript.quality_flags:
                    flags = ",".join(sorted(transcript.quality_flags))
                    header += f" # {flags}"
                
                f.write(header + "\n")
                
                # Write sequence in 80-character lines
                for i in range(0, len(sequence), 80):
                    f.write(sequence[i:i+80] + "\n")
        
        logging.info(f"Generated cleaned AA sequences: {output_file}")
        return str(output_file)
    
    def _generate_reports(self, genes: Dict[str, Gene], output_path: Path) -> List[str]:
        """Generate processing reports."""
        report_files = []
        
        # Generate manual review file (should be empty with current approach)
        manual_review_file = self._generate_manual_review_report(genes, output_path)
        report_files.append(manual_review_file)
        
        return report_files
    
    def _generate_manual_review_report(self, genes: Dict[str, Gene], output_path: Path) -> str:
        """Generate manual review report."""
        output_file = output_path / "manual_review_transcripts.txt"
        
        manual_review_genes = []
        for gene in genes.values():
            if not gene.representative_transcript:
                # Gene has no representative - needs manual review
                transcript_ids = [t.id for t in gene.transcripts]
                quality_flags = set()
                for t in gene.transcripts:
                    quality_flags.update(t.quality_flags)
                
                manual_review_genes.append({
                    'gene_id': gene.id,
                    'transcript_ids': transcript_ids,
                    'reason': 'no_representative_selected',
                    'quality_flags': quality_flags
                })
        
        with open(output_file, 'w') as f:
            f.write("# Manual Review Required\n")
            f.write("# Gene_ID\tTranscript_IDs\tReason\tQuality_Flags\n")
            
            for entry in manual_review_genes:
                transcript_list = ",".join(entry['transcript_ids'])
                flag_list = ",".join(sorted(entry['quality_flags']))
                
                f.write(f"{entry['gene_id']}\t{transcript_list}\t"
                       f"{entry['reason']}\t{flag_list}\n")
        
        logging.info(f"Generated manual review report: {output_file} "
                    f"({len(manual_review_genes)} genes requiring review)")
        return str(output_file)